"""
This file defines a set of distributions that will be checked using a Chi^2
statistical hypothesis test. The objective of this test is to ensure that the
distribution generated by a sample generator really matches the target
distribution. Tests are executed as part of the automated test suite, which
can be run using the following commands:

    $ source setpath.sh
    $ python -m pytest

They can also be executed in a visual manner using the warp visualizer utility

    $ source setpath.sh
    $ python -m mitsuba.ui.visualizer

Each entry of the DISTRIBUTIONS table is a tuple with the following entries:

    1. Name of the test

    2. An adapter that explains the domain of the distribution (see chi2.py)

    3. A nested tuple containing
        1. A sample generator
        2. A probability function

    4. A dictionary of settings that can be used to modify the test behavior

"""

from __future__ import division

import mitsuba

from mitsuba.scalar_rgb.core import float_dtype

from mitsuba.core.chi2 import SphericalDomain, PlanarDomain, LineDomain
from mitsuba.core.chi2 import (
    SpectrumAdapter, BSDFAdapter, MicrofacetAdapter,
    InteractiveBSDFAdapter, EnvironmentAdapter)
from mitsuba.scalar_rgb.render import MicrofacetDistribution, MicrofacetType
from mitsuba.scalar_rgb.core import Bitmap, Thread
from mitsuba.test.util import fresolver_append_path
import numpy as np


def deg2rad(value):
    return value * np.pi / 180

DEFAULT_SETTINGS   = {'sample_dim': 2, 'ires': 10, 'res': 101, 'parameters': []}
DEFAULT_SETTINGS_1 = dict(DEFAULT_SETTINGS, sample_dim=1)
DEFAULT_SETTINGS_3 = dict(DEFAULT_SETTINGS, sample_dim=3)


try:
    from mitsuba.packet_rgb.core import warp

    DISTRIBUTIONS = [
        ('Uniform square', PlanarDomain(np.array([[0, 1],
                                                [0, 1]])),
        (lambda x: x,
        lambda x: np.ones(x.shape[0])),
        DEFAULT_SETTINGS),

        ('Uniform square (concentric)', PlanarDomain(np.array([[0, 1],
                                                [0, 1]])),
        (warp.square_to_uniform_square_concentric,
        lambda x: np.ones(x.shape[0])),
        DEFAULT_SETTINGS),

        ('Uniform triangle', PlanarDomain(np.array([[0, 1],
                                                    [0, 1]])),
        (warp.square_to_uniform_triangle,
        warp.square_to_uniform_triangle_pdf),
        dict(DEFAULT_SETTINGS, res=100)),

        ('Tent function', PlanarDomain(np.array([[-1, 1],
                                                [-1, 1]])),
        (warp.square_to_tent,
        warp.square_to_tent_pdf),
        DEFAULT_SETTINGS),

        ('Uniform disk', PlanarDomain(),
        (warp.square_to_uniform_disk,
        warp.square_to_uniform_disk_pdf),
        DEFAULT_SETTINGS),

        ('Uniform disk (concentric)', PlanarDomain(),
        (warp.square_to_uniform_disk_concentric,
        warp.square_to_uniform_disk_concentric_pdf),
        DEFAULT_SETTINGS),

        ('Uniform sphere', SphericalDomain(),
        (warp.square_to_uniform_sphere,
        warp.square_to_uniform_sphere_pdf),
        DEFAULT_SETTINGS),

        ('Uniform hemisphere', SphericalDomain(),
        (warp.square_to_uniform_hemisphere,
        warp.square_to_uniform_hemisphere_pdf),
        DEFAULT_SETTINGS),

        ('Cosine hemisphere', SphericalDomain(),
        (warp.square_to_cosine_hemisphere,
        warp.square_to_cosine_hemisphere_pdf),
        DEFAULT_SETTINGS),

        ('Uniform cone', SphericalDomain(),
        (lambda sample, angle:
            warp.square_to_uniform_cone(sample, np.cos(deg2rad(angle))),
        lambda v, angle:
            warp.square_to_uniform_cone_pdf(v, np.cos(deg2rad(angle)))),
        dict(DEFAULT_SETTINGS,
            parameters=[
                ('Cutoff angle', [1e-4, 180, 20])
            ])),

        ('Beckmann distribution', SphericalDomain(),
        (lambda sample, value:
            warp.square_to_beckmann(sample,
                np.exp(np.log(0.05) * (1 - value) + np.log(1) * value)),
        lambda v, value:
            warp.square_to_beckmann_pdf(v,
                np.exp(np.log(0.05) * (1 - value) + np.log(1) * value))),
        dict(DEFAULT_SETTINGS,
            parameters=[
                ('Roughness', [0, 1, 0.6])
            ])),

        ('von Mises-Fisher distribution', SphericalDomain(),
        (warp.square_to_von_mises_fisher,
        warp.square_to_von_mises_fisher_pdf),
        dict(DEFAULT_SETTINGS,
            parameters=[
                ('Concentration', [0, 100, 2])
            ])),

        ('Rough fiber distribution', SphericalDomain(),
        (lambda sample, kappa, incl: warp.square_to_rough_fiber(
            sample, np.tile(np.array([np.sin(deg2rad(incl)), 0, np.cos(deg2rad(incl))], dtype=float_dtype), [sample.shape[0], 1]),
            np.tile(np.array([1, 0, 0], dtype=float_dtype), [sample.shape[0], 1]), kappa),
        lambda v, kappa, incl: warp.square_to_rough_fiber_pdf(
            v, np.tile([np.sin(deg2rad(incl)), 0, np.cos(deg2rad(incl))], [v.shape[0], 1]),
            np.tile([1, 0, 0], [v.shape[0], 1]), kappa)),
        dict(DEFAULT_SETTINGS,
            sample_dim=3,
            parameters=[
                ('Concentration', [0, 500, 10]),
                ('Inclination', [0, 90, 20])
            ])
        ),

        ('Spectrum: test', LineDomain([300.0, 850.0]),
        SpectrumAdapter("""<spectrum version="2.0.0" type="interpolated">
            <float name="lambda_min" value="300"/>
            <float name="lambda_max" value="850"/>
            <string name="values" value="1, 5, 3, 6"/>
        </spectrum>"""),
        DEFAULT_SETTINGS_1),

        ('Spectrum: d65', LineDomain([360.0, 830.0]),
        SpectrumAdapter('<spectrum version="2.0.0" type="d65"/>'),
        DEFAULT_SETTINGS_1),

        ('Spectrum: blackbody', LineDomain([360.0, 830.0]),
        SpectrumAdapter('<spectrum version="2.0.0" type="blackbody">'
                        '   <float name="temperature" value="%f"/>'
                        '</spectrum>'),
        dict(DEFAULT_SETTINGS,
            sample_dim=1,
            parameters=[
                ('Temperature', [0, 8000, 3000]),
            ])),

        ('Spectrum: rgb', LineDomain([360.0, 830.0]),
        (lambda x: mitsuba.packet_rgb.core.sample_rgb_spectrum(x)[0],
        mitsuba.packet_rgb.core.pdf_rgb_spectrum),
        DEFAULT_SETTINGS_1),

        ('Microfact: Beckmann, all, 0.5', SphericalDomain(),
        MicrofacetAdapter(MicrofacetType.Beckmann, 0.5, False),
        DEFAULT_SETTINGS),
        ('Microfact: Beckmann, all, 0.1', SphericalDomain(),
        MicrofacetAdapter(MicrofacetType.Beckmann, 0.1, False),
        DEFAULT_SETTINGS),

        ('Microfact: Beckmann, vis, 0.5', SphericalDomain(),
        MicrofacetAdapter(MicrofacetType.Beckmann, 0.5, True),
        dict(DEFAULT_SETTINGS,
            parameters=[('Angle of incidence', [0, 90, 30])])),
        ('Microfact: Beckmann, vis, 0.1', SphericalDomain(),
        MicrofacetAdapter(MicrofacetType.Beckmann, 0.1, True),
        dict(DEFAULT_SETTINGS,
            parameters=[('Angle of incidence', [0, 90, 30])])),

        ('Microfact: GGX, all, 0.5', SphericalDomain(),
        MicrofacetAdapter(MicrofacetType.GGX, 0.5, False),
        DEFAULT_SETTINGS),
        ('Microfact: GGX, all, 0.1', SphericalDomain(),
        MicrofacetAdapter(MicrofacetType.GGX, 0.1, False),
        DEFAULT_SETTINGS),

        ('Microfact: GGX, vis, 0.5', SphericalDomain(),
        MicrofacetAdapter(MicrofacetType.GGX, 0.5, True),
        dict(DEFAULT_SETTINGS,
            parameters=[('Angle of incidence', [0, 90, 30])])),
        ('Microfact: GGX, vis, 0.1', SphericalDomain(),
        MicrofacetAdapter(MicrofacetType.GGX, 0.1, True),
        dict(DEFAULT_SETTINGS,
            parameters=[('Angle of incidence', [0, 90, 30])])),

        ('Diffuse BSDF', SphericalDomain(),
        BSDFAdapter("diffuse", ''), DEFAULT_SETTINGS_3),

        ('Rough conductor BSDF - smooth', SphericalDomain(),
        BSDFAdapter("roughconductor", """
            <float name="alpha" value="0.05"/>
        """), DEFAULT_SETTINGS_3),
        ('Rough conductor BSDF - rough', SphericalDomain(),
        BSDFAdapter("roughconductor", """
            <float name="alpha" value="0.25"/>
        """), DEFAULT_SETTINGS_3),
        ('Rough conductor BSDF - rough - alternative wi', SphericalDomain(),
        BSDFAdapter("roughconductor", """
            <float name="alpha" value="0.25"/>
        """, wi=[0.970942, 0, 0.239316]), DEFAULT_SETTINGS_3),

        ('Rough conductor BSDF', SphericalDomain(),
        InteractiveBSDFAdapter("roughconductor", """
            <boolean name="sample_visible" value="false"/>
            <string name="distribution" value="beckmann"/>
            <float name="alpha_u" value="%f"/>
            <float name="alpha_v" value="%f"/>
        """), dict(DEFAULT_SETTINGS,
            parameters=[
                ('theta_i', [0, 90, 30]),
                ('phi_i', [0, 360, 0]),
                ('alpha_u', [0, 1, 0.2]),
                ('alpha_v', [0, 1, 0.2])
        ])),

        ('Rough conductor BSDF (VNDF)', SphericalDomain(),
        InteractiveBSDFAdapter("roughconductor", """
            <boolean name="sample_visible" value="true"/>
            <string name="distribution" value="beckmann"/>
            <float name="alpha_u" value="%f"/>
            <float name="alpha_v" value="%f"/>
        """), dict(DEFAULT_SETTINGS,
            parameters=[
                ('theta_i', [0, 90, 30]),
                ('phi_i', [0, 360, 0]),
                ('alpha_u', [0, 1, 0.2]),
                ('alpha_v', [0, 1, 0.2])
        ])),


        # ('Rough dielectric BSDF - smooth', SphericalDomain(),
        #  BSDFAdapter("roughdielectric", """
        #     <float name="alpha" value="0.05"/>
        #  """), DEFAULT_SETTINGS_3),
        ('Rough dielectric BSDF - rough', SphericalDomain(),
        BSDFAdapter("roughdielectric", """
            <float name="alpha" value="0.25"/>
        """), DEFAULT_SETTINGS_3),
        ('Rough dielectric BSDF - rough - alternative wi', SphericalDomain(),
        BSDFAdapter("roughdielectric", """
            <float name="alpha" value="0.25"/>
        """, wi=[0.48666426,  0.32444284,  0.81110711]), DEFAULT_SETTINGS_3),

        ('Rough plastic BSDF - smooth', SphericalDomain(),
        BSDFAdapter("roughplastic", """
            <float name="alpha" value="0.05"/>
            <spectrum name="specular_reflectance" value="0.7"/>
            <spectrum name="diffuse_reflectance" value="0.1"/>
        """), DEFAULT_SETTINGS_3),
        ('Rough plastic BSDF - rough', SphericalDomain(),
        BSDFAdapter("roughplastic", """
            <float name="alpha" value="0.25"/>
            <spectrum name="specular_reflectance" value="0.4"/>
            <spectrum name="diffuse_reflectance" value="0.9"/>
        """), DEFAULT_SETTINGS_3),

        #('Measured BSDF', SphericalDomain(),
        # InteractiveBSDFAdapter("measured", """
        #    <string name="filename" value="ggx_spec.bsdf"/>
        #"""), dict(DEFAULT_SETTINGS,
        #     parameters=[
        #         ('theta_i', [0, 90, 30]),
        #         ('phi_i', [0, 360, 0])
        # ]))

        ('Environment map (museum)', SphericalDomain(),
        EnvironmentAdapter("envmap", """
            <string name="filename" value="resources/data/envmap/museum.exr"/>
        """), DEFAULT_SETTINGS)
    ]

    @fresolver_append_path
    def Warp2D0Test(hierarchical):
        try:
            from mitsuba.packet_rgb.core.warp import Hierarchical2D0, Marginal2D0
        except ImportError:
            pass

        fr = Thread.thread().file_resolver()

        prefix = 'resources/data/tests/warp/'
        img0 = np.array(Bitmap(fr.resolve(prefix + 'small.png')), dtype=np.float32)
        if hierarchical:
            d = Hierarchical2D0(img0.squeeze())
        else:
            d = Marginal2D0(img0.squeeze())

        def sample_functor(sample, *args):
            return d.sample(sample, *args)[0]

        def pdf_functor(p, *args):
            return d.eval(p, *args)

        return sample_functor, pdf_functor


    @fresolver_append_path
    def Warp2D2Test(hierarchical):
        try:
            from mitsuba.packet_rgb.core.warp import Hierarchical2D2, Marginal2D2
        except ImportError:
            pass

        fr = Thread.thread().file_resolver()

        prefix = 'resources/data/tests/warp/'
        img0 = np.array(Bitmap(fr.resolve(prefix + 'img0.png')), dtype=np.float32)
        img1 = np.array(Bitmap(fr.resolve(prefix + 'img1.png')), dtype=np.float32)
        img2 = np.array(Bitmap(fr.resolve(prefix + 'img2.png')), dtype=np.float32)
        img3 = np.array(Bitmap(fr.resolve(prefix + 'img3.png')), dtype=np.float32)

        tensor = np.full((2, 2, 512, 512), 0, dtype=np.float32)
        tensor[0, 0, :, :] = img0.squeeze()
        tensor[0, 1, :, :] = img1.squeeze()
        tensor[1, 0, :, :] = img2.squeeze()
        tensor[1, 1, :, :] = img3.squeeze()

        if hierarchical:
            d = Hierarchical2D2(tensor, [[0, 1], [0, 1]])
        else:
            d = Marginal2D2(tensor, [[0, 1], [0, 1]])

        def sample_functor(sample, *args):
            return d.sample(sample, *args)[0]

        def pdf_functor(p, *args):
            return d.eval(p, *args)

        return sample_functor, pdf_functor


    DISTRIBUTIONS += [
        ('Hierarchical warp (small)',
        PlanarDomain(np.array([[0, 1], [0, 1]])),
        Warp2D0Test(hierarchical=True),
        DEFAULT_SETTINGS),
        ('Hierarchical warp (4D, big)',
        PlanarDomain(np.array([[0, 1], [0, 1]])),
        Warp2D2Test(hierarchical=True),
        dict(DEFAULT_SETTINGS,
            parameters=[
                ('param0', [0, 1, 0.5]),
                ('param1', [0, 1, 0.005])
            ])),
        ('Marginal warp (small)',
        PlanarDomain(np.array([[0, 1], [0, 1]])),
        Warp2D0Test(hierarchical=False),
        DEFAULT_SETTINGS),
        ('Marginal warp (4D, big)',
        PlanarDomain(np.array([[0, 1], [0, 1]])),
        Warp2D2Test(hierarchical=False),
        dict(DEFAULT_SETTINGS,
            parameters=[
                ('param0', [0, 1, 0.5]),
                ('param1', [0, 1, 0.005])
            ]))
    ]
except ImportError:
    DISTRIBUTIONS = []

